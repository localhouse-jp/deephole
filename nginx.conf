worker_processes auto;

events {
    worker_connections 1024;
}

http {
    # Logging
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log info;

    # WebSocket support
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    server {
        listen 80 reuseport;
        server_name _;

        # Proxy headers
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_read_timeout 60s;
        proxy_send_timeout 60s;

        set $upstream_target "";

        # Short ID to IP:Port resolution via Base32 decoding
        access_by_lua_block {
            local function b32decode_nopad_lower_to_bytes(input)
                if not input or input == "" then 
                    return nil, "empty" 
                end
                
                local alpha = "abcdefghijklmnopqrstuvwxyz234567"
                local map = {}
                for i = 1, #alpha do
                    map[alpha:sub(i,i)] = i - 1
                end
                
                input = input:gsub("=", ""):lower()
                local bits, val = 0, 0
                local out = {}
                
                for i = 1, #input do
                    local c = input:sub(i,i)
                    local v = map[c]
                    if v == nil then
                        return nil, "invalid-char:" .. c
                    end
                    
                    val = (val << 5) | v
                    bits = bits + 5
                    
                    if bits >= 8 then
                        bits = bits - 8
                        local byte = (val >> bits) & 0xFF
                        out[#out+1] = string.char(byte)
                        val = val & ((1 << bits) - 1)
                    end
                end
                
                return table.concat(out)
            end

            local function valid_ipv4(a, b, c, d)
                a, b, c, d = tonumber(a), tonumber(b), tonumber(c), tonumber(d)
                if not a or not b or not c or not d then 
                    return false 
                end
                return a >= 0 and a <= 255 and b >= 0 and b <= 255 and 
                       c >= 0 and c <= 255 and d >= 0 and d <= 255
            end

            -- Extract short ID from hostname's first label
            local host = ngx.var.host or ""
            local code = host:match("^([^.]+)%.")
            if not code then
                -- Skip processing for localhost or direct IP access
                if host == "localhost" or host:match("^%d+%.%d+%.%d+%.%d+") then
                    return
                end
                return ngx.exit(ngx.HTTP_BAD_REQUEST)
            end

            -- Decode Base32 (no padding)
            local raw, err = b32decode_nopad_lower_to_bytes(code)
            if not raw then
                ngx.log(ngx.WARN, "b32 decode error: ", err)
                return ngx.exit(ngx.HTTP_NOT_FOUND)
            end

            -- Expect 6 bytes: [0..3]=IPv4, [4..5]=Port(big-endian)
            if #raw ~= 6 then
                ngx.log(ngx.WARN, "decoded length invalid: ", #raw)
                return ngx.exit(ngx.HTTP_BAD_REQUEST)
            end
            
            local b1, b2, b3, b4, p1, p2 = raw:byte(1, 6)
            local ip = string.format("%d.%d.%d.%d", b1, b2, b3, b4)
            
            if not valid_ipv4(b1, b2, b3, b4) then
                return ngx.exit(ngx.HTTP_BAD_REQUEST)
            end
            
            local port = (p1 << 8) | p2
            if port < 1 or port > 65535 then
                return ngx.exit(ngx.HTTP_BAD_REQUEST)
            end

            ngx.var.upstream_target = ip .. ":" .. tostring(port)
            ngx.req.set_header("X-Edge-Target", ngx.var.upstream_target)
        }

        location / {
            # Fallback for localhost/direct access
            if ($upstream_target = "") {
                return 200 "OpenResty Edge Server - Ready\nAccess via: [shortid].yourdomain.com\n";
                add_header Content-Type text/plain;
            }
            proxy_pass http://$upstream_target;
        }
    }
}